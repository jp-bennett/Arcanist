using Kingmaker.PubSubSystem;
using Kingmaker.RuleSystem.Rules.Abilities;
using Kingmaker.UnitLogic;
using Kingmaker.UnitLogic.Buffs.Components;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using ArcaneTide.Arcanist;
using Kingmaker.UnitLogic.Parts;
using Kingmaker.Blueprints.Classes;
using Kingmaker.Blueprints;
using Kingmaker.RuleSystem.Rules;
using Kingmaker.UnitLogic.Mechanics.Actions;
using Kingmaker.UnitLogic.Buffs.Blueprints;

namespace ArcaneTide.Components {
    class SRExploitsBuff : BuffLogic{
        public override void OnTurnOn() {
            base.OnTurnOn();
            unit = base.Owner;
            int SR = this.Calc() + (unit.HasFact(SpellResistance.exploitHigher) ? 11 : 6);
            m_AppliedId = new int?(unit.Ensure<UnitPartSpellResistance>().AddResistance(SR, null, null));
        }
        public override void OnRecalculate() {
            base.OnRecalculate();
            if(this.m_AppliedId != null) {
                UnitPartSpellResistance unitPartSpellResistance = base.Owner.Get<UnitPartSpellResistance>();
                if (unitPartSpellResistance != null) {
                    unitPartSpellResistance.Remove(this.m_AppliedId.Value);
                }
                this.m_AppliedId = null;
            }
            int SR = this.Calc() + (unit.HasFact(SpellResistance.exploitHigher) ? 11 : 6);
            m_AppliedId = new int?(unit.Ensure<UnitPartSpellResistance>().AddResistance(SR, null, null));
        }

        public override void OnTurnOff() {
            if (this.m_AppliedId != null) {
                UnitPartSpellResistance unitPartSpellResistance = base.Owner.Get<UnitPartSpellResistance>();
                if (unitPartSpellResistance != null) {
                    unitPartSpellResistance.Remove(this.m_AppliedId.Value);
                }
                this.m_AppliedId = null;
            }
            base.OnTurnOff();
        }

        private int Calc() {
            int ans = 0;
            foreach(var cls in classes) {
                ans += unit.Progression.GetClassLevel(cls);
            }
            return ans;
        }
        UnitDescriptor unit;
        public BlueprintCharacterClass[] classes;
        private int? m_AppliedId;
    }

    class SRDrainExploitComponent : RuleTargetLogicComponent<RuleSpellResistanceCheck> {
        public override void OnEventAboutToTrigger(RuleSpellResistanceCheck evt) {
            throw new NotImplementedException();
        }

        public override void OnEventDidTrigger(RuleSpellResistanceCheck evt) {
            var unit = evt.Target.Descriptor;
            if (evt.IsSpellResisted) {
                int spellLevel = evt.Context.SpellLevel;
                unit.Resources.Spend(resource, unit.Resources.GetResourceAmount(resource));
                unit.Resources.Restore(resource, spellLevel / 2);
            }
        }
        public BlueprintAbilityResource resource;
    }

    class UseSRDrainedPointsAction : ContextAction {
        public override string GetCaption() {
            return string.Empty;
        }

        public override void RunAction() {
            UnitDescriptor unit = base.Context.MaybeCaster.Descriptor;
            int drainedPoints = unit.Resources.GetResourceAmount(points);
            unit.Resources.Spend(points, drainedPoints);
            //when we use resource number to show how many points drained from the spell resisted,
            //on running the ability, it will first cost 1 resource.
            //so drainedPoints = the real points drained from the spell -1.
            unit.Resources.Restore(reservoir, drainedPoints + 1);
            if (unit.Buffs.HasFact(sr_buff)) {
                unit.Buffs.RemoveFact(sr_buff);
            }
        }
        public BlueprintAbilityResource points, reservoir;
        public BlueprintBuff sr_buff;
    }
}
